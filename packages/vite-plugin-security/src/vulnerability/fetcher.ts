import { execSync } from 'node:child_process';
import { existsSync, readFileSync } from 'node:fs';
import { resolve } from 'node:path';

import type {
  NpmAuditResult,
  NpmAuditVulnerability,
  OsvQueryResponse,
  OsvVulnerability,
  Severity,
  Vulnerability,
  VulnerabilityReport,
} from '../types/index.js';

/**
 * npm audit 심각도를 내부 Severity로 변환
 */
const mapNpmSeverity = (
  severity: NpmAuditVulnerability['severity'],
): Severity => {
  switch (severity) {
    case 'critical':
      return 'critical';
    case 'high':
      return 'high';
    case 'moderate':
      return 'warning';
    case 'low':
    case 'info':
    default:
      return 'info';
  }
};

/**
 * OSV CVSS 점수를 Severity로 변환
 */
const mapCvssSeverity = (score: string): Severity => {
  const numScore = parseFloat(score);
  if (numScore >= 9.0) return 'critical';
  if (numScore >= 7.0) return 'high';
  if (numScore >= 4.0) return 'warning';
  return 'info';
};

/**
 * npm audit 실행 및 결과 파싱
 */
export const runNpmAudit = (
  cwd: string = process.cwd(),
): NpmAuditResult | null => {
  try {
    // npm audit --json 실행
    // 취약점이 있어도 exit code가 0이 아닐 수 있으므로 try-catch 필요
    const result = execSync('npm audit --json 2>/dev/null || true', {
      encoding: 'utf-8',
      cwd,
      maxBuffer: 10 * 1024 * 1024, // 10MB
    });

    if (!result.trim()) {
      return null;
    }

    return JSON.parse(result) as NpmAuditResult;
  } catch {
    // npm audit 실행 실패 (package-lock.json 없음 등)
    return null;
  }
};

/**
 * pnpm audit 실행 및 결과 파싱
 */
export const runPnpmAudit = (
  cwd: string = process.cwd(),
): NpmAuditResult | null => {
  try {
    const result = execSync('pnpm audit --json 2>/dev/null || true', {
      encoding: 'utf-8',
      cwd,
      maxBuffer: 10 * 1024 * 1024,
    });

    if (!result.trim()) {
      return null;
    }

    // pnpm audit 결과는 npm audit과 유사한 형식
    return JSON.parse(result) as NpmAuditResult;
  } catch {
    return null;
  }
};

/**
 * 패키지 매니저 감지 및 audit 실행
 */
export const runAudit = (
  cwd: string = process.cwd(),
): NpmAuditResult | null => {
  // pnpm-lock.yaml 확인
  if (existsSync(resolve(cwd, 'pnpm-lock.yaml'))) {
    return runPnpmAudit(cwd);
  }

  // package-lock.json 확인
  if (existsSync(resolve(cwd, 'package-lock.json'))) {
    return runNpmAudit(cwd);
  }

  // yarn.lock은 별도 처리 필요 (일단 npm audit 시도)
  return runNpmAudit(cwd);
};

/**
 * via에서 상세 정보 추출
 */
const extractViaDetails = (via: NpmAuditVulnerability['via']) =>
  via.find(
    (v): v is { name: string; severity: string; title: string } =>
      typeof v === 'object' && 'title' in v,
  );

/**
 * fixAvailable 정보 파싱
 */
const parseFixAvailable = (
  fixAvailable: NpmAuditVulnerability['fixAvailable'],
): { fixedVersion?: string; fixAvailable: boolean } => {
  if (typeof fixAvailable === 'object') {
    return { fixedVersion: fixAvailable.version, fixAvailable: true };
  }
  return { fixAvailable };
};

/**
 * 단일 npm audit 취약점을 Vulnerability로 변환
 */
const convertNpmVuln = (
  packageName: string,
  vuln: NpmAuditVulnerability,
): Vulnerability => {
  const viaDetails = extractViaDetails(vuln.via);
  const title = viaDetails?.title ?? `Vulnerability in ${packageName}`;
  const id =
    typeof vuln.via[0] === 'string'
      ? vuln.via[0]
      : `npm-${packageName}-${vuln.severity}`;
  const { fixedVersion, fixAvailable } = parseFixAvailable(vuln.fixAvailable);

  return {
    packageName,
    id,
    title,
    description: `${title}. Affected range: ${vuln.range}`,
    severity: mapNpmSeverity(vuln.severity),
    vulnerableRange: vuln.range,
    fixedVersion,
    fixAvailable,
    references: [`https://www.npmjs.com/advisories?search=${packageName}`],
    source: 'npm-audit',
  };
};

/**
 * npm audit 결과를 통합 Vulnerability 형식으로 변환
 */
export const parseNpmAuditResult = (
  auditResult: NpmAuditResult,
): Vulnerability[] =>
  Object.entries(auditResult.vulnerabilities).map(([name, vuln]) =>
    convertNpmVuln(name, vuln),
  );

const OSV_API_URL = 'https://api.osv.dev/v1/query';

/**
 * OSV API 요청 바디 생성
 */
const createOsvRequestBody = (
  packageName: string,
  version?: string,
): Record<string, unknown> => {
  const body: Record<string, unknown> = {
    package: { name: packageName, ecosystem: 'npm' },
  };
  if (version) body.version = version;
  return body;
};

/**
 * OSV API 호출
 */
const callOsvApi = async (
  body: Record<string, unknown>,
): Promise<OsvQueryResponse | null> => {
  const response = await fetch(OSV_API_URL, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(body),
  });
  return response.ok ? ((await response.json()) as OsvQueryResponse) : null;
};

/**
 * OSV API로 단일 패키지 취약점 조회
 */
export const fetchOsvVulnerabilities = async (
  packageName: string,
  version?: string,
): Promise<OsvVulnerability[]> => {
  try {
    const body = createOsvRequestBody(packageName, version);
    const data = await callOsvApi(body);
    return data?.vulns ?? [];
  } catch {
    return [];
  }
};

/**
 * OSV 심각도 결정
 */
const determineOsvSeverity = (osv: OsvVulnerability): Severity => {
  if (osv.severity?.[0]?.score) {
    return mapCvssSeverity(osv.severity[0].score);
  }
  if (osv.database_specific?.severity) {
    const dbSeverity = osv.database_specific.severity.toLowerCase();
    if (dbSeverity === 'critical') return 'critical';
    if (dbSeverity === 'high') return 'high';
    if (dbSeverity === 'moderate' || dbSeverity === 'medium') return 'warning';
  }
  return 'warning';
};

/**
 * OSV affected 범위에서 수정 버전 찾기
 */
const findFixedVersion = (
  osv: OsvVulnerability,
  packageName: string,
): string | undefined => {
  const affected = osv.affected?.find((a) => a.package.name === packageName);
  const fixEvent = affected?.ranges?.[0]?.events?.find((e) => e.fixed);
  return fixEvent?.fixed;
};

/**
 * OSV affected 범위 문자열 생성
 */
const buildVulnerableRange = (
  osv: OsvVulnerability,
  packageName: string,
): string => {
  const affected = osv.affected?.find((a) => a.package.name === packageName);
  return (
    affected?.ranges?.[0]?.events
      ?.map((e) =>
        e.introduced ? `>=${e.introduced}` : e.fixed ? `<${e.fixed}` : '',
      )
      .filter(Boolean)
      .join(' ') ?? '*'
  );
};

/**
 * OSV 참고 링크 추출
 */
const extractOsvReferences = (osv: OsvVulnerability): string[] =>
  osv.references
    ?.filter((r) => r.type === 'ADVISORY' || r.type === 'WEB')
    .map((r) => r.url)
    .slice(0, 3) ?? [];

/**
 * OSV 취약점을 통합 형식으로 변환
 */
export const parseOsvVulnerability = (
  osv: OsvVulnerability,
  packageName: string,
): Vulnerability => {
  const fixedVersion = findFixedVersion(osv, packageName);
  return {
    packageName,
    id: osv.aliases?.find((a) => a.startsWith('CVE-')) ?? osv.id,
    title: osv.summary || `Vulnerability in ${packageName}`,
    description: osv.details || osv.summary || '',
    severity: determineOsvSeverity(osv),
    vulnerableRange: buildVulnerableRange(osv, packageName),
    fixedVersion,
    fixAvailable: !!fixedVersion,
    references: extractOsvReferences(osv),
    source: 'osv',
  };
};

/**
 * 여러 패키지에 대해 OSV API 조회
 */
export const fetchOsvForPackages = async (
  packages: Array<{ name: string; version?: string }>,
): Promise<Vulnerability[]> => {
  const vulnerabilities: Vulnerability[] = [];

  // 병렬 요청 (최대 10개씩 배치)
  const batchSize = 10;
  for (let i = 0; i < packages.length; i += batchSize) {
    const batch = packages.slice(i, i + batchSize);
    const results = await Promise.all(
      batch.map(async (pkg) => {
        const osvVulns = await fetchOsvVulnerabilities(pkg.name, pkg.version);
        return osvVulns.map((osv) => parseOsvVulnerability(osv, pkg.name));
      }),
    );

    vulnerabilities.push(...results.flat());
  }

  return vulnerabilities;
};

type PackageDep = { name: string; version: string };

/**
 * 의존성 객체를 배열로 변환
 */
const depsToArray = (deps?: Record<string, string>): PackageDep[] =>
  deps
    ? Object.entries(deps).map(([name, version]) => ({
        name,
        version: version.replace(/^[\^~]/, ''),
      }))
    : [];

/**
 * package.json에서 의존성 목록 추출
 */
export const getPackageDependencies = (
  cwd: string = process.cwd(),
): PackageDep[] => {
  const packageJsonPath = resolve(cwd, 'package.json');
  if (!existsSync(packageJsonPath)) return [];

  try {
    const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8')) as {
      dependencies?: Record<string, string>;
      devDependencies?: Record<string, string>;
    };
    return [
      ...depsToArray(packageJson.dependencies),
      ...depsToArray(packageJson.devDependencies),
    ];
  } catch {
    return [];
  }
};

/**
 * npm audit + OSV 결과 병합 (중복 제거)
 */
export const mergeVulnerabilities = (
  npmVulns: Vulnerability[],
  osvVulns: Vulnerability[],
): Vulnerability[] => {
  const merged = new Map<string, Vulnerability>();

  // npm audit 결과 먼저 추가
  for (const vuln of npmVulns) {
    const key = `${vuln.packageName}:${vuln.id}`;
    merged.set(key, vuln);
  }

  // OSV 결과 추가 (더 상세한 정보가 있으면 업데이트)
  for (const vuln of osvVulns) {
    const key = `${vuln.packageName}:${vuln.id}`;
    const existing = merged.get(key);

    if (!existing) {
      merged.set(key, vuln);
    } else if (vuln.description.length > existing.description.length) {
      // OSV가 더 상세한 설명을 가진 경우 업데이트
      merged.set(key, {
        ...existing,
        description: vuln.description,
        references: [...new Set([...existing.references, ...vuln.references])],
      });
    }
  }

  return Array.from(merged.values());
};

/**
 * 취약점 요약 계산
 */
const calculateVulnSummary = (vulnerabilities: Vulnerability[]) => {
  const summary = {
    critical: 0,
    high: 0,
    moderate: 0,
    low: 0,
    total: vulnerabilities.length,
  };
  for (const vuln of vulnerabilities) {
    if (vuln.severity === 'critical') summary.critical++;
    else if (vuln.severity === 'high') summary.high++;
    else if (vuln.severity === 'warning') summary.moderate++;
    else summary.low++;
  }
  return summary;
};

/**
 * OSV API로 취약점 조회 및 병합
 */
const fetchAndMergeOsvVulns = async (
  cwd: string,
  vulnerabilities: Vulnerability[],
  includeDevDeps: boolean,
): Promise<Vulnerability[]> => {
  const packages = getPackageDependencies(cwd);
  const filteredPackages = includeDevDeps
    ? packages
    : packages.filter((p) => !p.name.startsWith('@types/'));
  const osvVulns = await fetchOsvForPackages(filteredPackages);
  return mergeVulnerabilities(vulnerabilities, osvVulns);
};

/**
 * 전체 취약점 검사 실행
 */
export const scanVulnerabilities = async (
  cwd: string = process.cwd(),
  options: { useOsv?: boolean; includeDevDeps?: boolean } = {},
): Promise<VulnerabilityReport> => {
  const { useOsv = true, includeDevDeps = false } = options;

  const auditResult = runAudit(cwd);
  let vulnerabilities = auditResult ? parseNpmAuditResult(auditResult) : [];

  if (useOsv) {
    vulnerabilities = await fetchAndMergeOsvVulns(
      cwd,
      vulnerabilities,
      includeDevDeps,
    );
  }

  return {
    vulnerabilities,
    summary: calculateVulnSummary(vulnerabilities),
    scannedPackages: getPackageDependencies(cwd).length,
  };
};
