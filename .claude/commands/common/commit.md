---
allowed-tools: Bash(git status:*), Bash(git branch:*), Bash(git diff:*), Bash(git add:*), Bash(git commit:*), Bash(git checkout:*), Bash(git log:*)
description: Conventional Commits 형식으로 commit 메시지를 생성하고, 사용자 승인 후 git commit 실행
---

<!--
🔄 이 파일은 fe-shared-project에서 자동 동기화됩니다
관리 위치: https://github.com/musinsa/fe-shared-project
⚠️ 이 파일을 직접 수정하지 마세요. 다음 동기화 시 덮어씌워집니다.
-->

# Claude Command: Commit

이 명령어는 [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/) 형식으로 commit 메시지를 생성하고 실행합니다.

**⚠️ 중요: Claude는 이 파일의 모든 명세를 정확히 따라야 합니다. 특히 main/master 브랜치 체크는 필수입니다.**

---

## 🚨 컨텍스트 압축 후에도 반드시 지켜야 할 필수 체크리스트

**커밋 메시지는 아래 6가지 필수 요소를 모두 포함해야 합니다:**

### ✅ 1. 제목 형식
```
[type]: [ISSUE-KEY] [한글 제목]
```
- 예: `feat: FE-1234 사용자 인증 시스템 추가`

### ✅ 2. 변경사항 목록 (별표 사용)
```
* 첫 번째 변경사항
* 두 번째 변경사항
```
- **주의**: `-` 대신 반드시 `*` 사용

### ✅ 3. 기여도 섹션 (필수)
```
## 변경사항 (사용자: X% | AI: Y%)
### 사용자 기여 (X%):
* 아이디어 제시, 방향성 결정 등

### AI 기여 (Y%):
* 코드 작성, 테스트 등
```
- 기여도는 코드 라인 수가 아닌 **아이디어/설계/의사결정의 출처**로 판단

### ✅ 4. AI 작업 메트릭 (필수)
```
## AI 작업 메트릭 (AI Metrics)
* **모델**: Claude Sonnet 4.5
* **토큰 사용량**: Input 15,000 / Output 8,500 (Total: 23,500)
* **대화 턴 수**: 3회
* **주요 작업**: 코드 작성, 디버깅
```
- **⚠️ 측정 범위**: 토큰 사용량, 대화 턴 수, 주요 작업 모두 **해당 커밋 작업에 직접 관련된 것만** 집계
- **토큰 사용량 작성 우선순위**:
  1. **최우선**: Input/Output을 분리할 수 있다면 `Input X / Output Y (Total: Z)` 형식으로 작성
  2. **차선책**: Input/Output 분리가 불가능하면 `Total: Z` 형식으로만 작성
  3. **최후**: 토큰 사용량을 전혀 알 수 없는 경우에만 해당 줄 생략
- **측정 범위 판단**:
  - **포함**: 커밋 대상 코드 작성/수정, 관련 디버깅, 해당 기능 테스트, 해당 커밋 관련 논의
  - **제외**: 커밋과 명백히 무관한 탐색, 다른 이슈 논의, 일반 질문
  - **판단 기준**: 애매한 경우 포함시키되, 명백히 다른 작업은 제외

### ✅ 5. Jira 링크 (필수)
```
https://jira.team.musinsa.com/browse/FE-1234
```
- 브랜치명에서 이슈 키 추출
- temp/ 브랜치는 생략 가능

### ✅ 6. Co-author (필수)
```
Co-authored-By: Claude <noreply@anthropic.com>
```

---

## 자동 실행 Git 명령어

다음 명령어들이 자동으로 실행되어 컨텍스트에 포함됩니다:

- 현재 브랜치: !`git branch --show-current`
- Git 상태: !`git status`
- Staged 변경사항: !`git diff --cached`
- Unstaged 변경사항: !`git diff`
- 최근 커밋 로그 (3개): !`git log -3 --oneline`

## 사용법

기본 사용법 (commit 메시지만 생성):

```bash
/commit
```

옵션과 함께:

```bash
/commit --auto           # 자동으로 commit까지 실행
/commit --auto-no-verify # 자동 commit 실행 (사전 검사 제외)
```

## 명령어 옵션

- `--auto`: commit 메시지 생성 후 자동으로 commit까지 실행 (사전 검사 포함)
- `--auto-no-verify`: commit 메시지 생성 후 자동으로 commit까지 실행 (사전 검사 제외)

## 이 명령어가 하는 일

### 기본 모드 (`/commit`)

1. 현재 브랜치가 main 또는 master인지 확인합니다.
    - 위의 "자동 실행 Git 명령어" 섹션에서 실행된 `현재 브랜치` 결과를 확인합니다.
    - main/master 브랜치인 경우: main 브랜치에서는 직접 커밋이 불가하므로 임시 브랜치 생성 여부를 묻습니다
        - "main 브랜치에서는 직접 커밋할 수 없습니다. 임시 브랜치를 생성하시겠습니까? (y/n)" 질문
        - 'y' 또는 긍정적 응답: `git checkout -b temp/브랜치명` 으로 임시 브랜치 생성 후 체크아웃하여 커밋 과정 계속 진행
        - 'n' 또는 부정적 응답: 커밋 과정을 중단하고 브랜치 생성 가이드 제공
            - "커밋 과정을 중단합니다."
            - "main 브랜치에서 작업하려면 먼저 새 브랜치를 생성해주세요:"
            - `git checkout -b feature/작업내용-설명` 또는 `git checkout -b fix/버그-설명`
            - "브랜치 생성 후 다시 `/commit` 명령어를 실행해주세요."
    - 임시 브랜치 생성 시:
        - 임시 브랜치명 형식: `temp/변경내용-요약` (최대 4개 단어, kebab-case)
        - 변경사항을 분석하여 의미 있는 브랜치명 자동 생성 (예: `temp/update-commit-rules`, `temp/fix-auth-bug`, `temp/add-user-validation`)
        - 브랜치 생성 후 "임시 브랜치 '{브랜치명}'을 생성하고 체크아웃했습니다. 커밋을 계속 진행합니다." 메시지 표시

2. Staging 상태 확인 및 처리:
    - 위의 "자동 실행 Git 명령어" 섹션에서 실행된 `Git 상태`, `Staged 변경사항`, `Unstaged 변경사항` 결과를 확인합니다.
    - 조건 분기:
        - A. Staging된 파일이 있는 경우:
            - 절대로 추가적으로 staging하거나 unstaging하지 않습니다
            - 사용자가 의도적으로 특정 파일만 staging한 것이므로 존중합니다
            - 자동 실행된 `Staged 변경사항` (git diff --cached) 결과를 분석
            - Staging된 파일만을 기반으로 다음 단계 진행
        - B. Staging된 파일이 없는 경우:
            - `git add .`로 모든 수정된 파일과 새 파일을 자동 추가
            - 추가 후 다시 변경사항을 분석
            - 모든 변경사항을 기반으로 다음 단계 진행

3. 변경사항 분석:
    - 자동 실행된 diff 결과를 분석하여 여러 개의 논리적으로 구분되는 변경사항이 있는지 확인합니다.
    - 여러 개의 구분되는 변경사항이 감지되면 commit을 여러 개의 작은 commit으로 나누도록 제안합니다.

4. Commit 메시지 생성:
    - 각 commit에 대해 Conventional Commits 형식으로 commit 메시지를 생성합니다.
    - Commit 메시지는 한글로 작성합니다.
    - 브랜치명에서 Jira 이슈 키를 추출하여 commit 메시지 제목에 추가합니다.
        - 브랜치명에서 `[A-Z]{2,}-[0-9]+` 패턴을 찾아 이슈 키를 추출합니다 (대문자만 허용)
        - 예: `feature/FE-1234-login` → `feat: FE-1234 로그인 기능 추가`
        - 주의: 커밋 메시지 검증에 의해 Jira 티켓은 반드시 대문자여야 합니다 (`FE-1234`, `QAT-5678` 등)
        - 임시 브랜치의 경우: `temp/` 브랜치는 Jira 티켓을 포함하지 않으므로 티켓 번호 없이 커밋 메시지 생성 (예: `feat: 로그인 기능 추가`)
    - Commit 메시지에서 목록은 `*`로 표현합니다 (- 대신 \* 사용)
    - 기여도 정보를 추가합니다:
        - **기여도 산정 프로세스**:
            1. 대화 전체 맥락 검토: 사용자가 제시한 방향성, 의사결정, 피드백 파악
            2. Staged 변경사항 분석: git diff --cached로 최종 반영된 코드 확인
            3. 비교 분석: 사용자 제안 내용 vs 최종 코드의 일치도 검토
            4. 질적 평가: 단순 라인 수가 아닌 로직/구조/아이디어의 기여도 중심으로 판단
        - `## 변경사항 (사용자: X% | AI: Y%)` 섹션 추가
        - 사용자와 AI의 기여 내용을 각각 명시 (기여도 산정 가이드라인 참조)
        - 파일 경로 등 구체적인 정보 포함
    - AI 작업 메트릭을 추가합니다:
        - `## AI 작업 메트릭 (AI Metrics)` 섹션 추가
        - **⚠️ 측정 범위 원칙**: 토큰 사용량, 대화 턴 수, 주요 작업 내용 모두 **해당 커밋 작업에 직접 관련된 것만** 집계
            - **포함**: 커밋 대상 코드 작성/수정, 관련 디버깅, 해당 기능 테스트, 해당 커밋 관련 논의 및 질문, 연관된 문서 작성
            - **제외**: 커밋과 명백히 무관한 탐색, 다른 이슈 논의, 일반 질문, 별도 작업
            - **판단 기준**: 애매한 경우 포함시키되, 명백히 다른 작업은 제외
        - **모델 정보**: `* **모델**: {모델명}` (예: Claude Sonnet 4.5, GPT-4, Cursor AI 등)
        - **토큰 사용량 작성 우선순위**:
            1. **최우선**: Input/Output을 분리할 수 있다면 `Input X / Output Y (Total: Z)` 형식으로 작성
            2. **차선책**: Input/Output 분리가 불가능하면 `Total: Z` 형식으로만 작성
            3. **최후**: 토큰 사용량을 전혀 알 수 없는 경우에만 해당 줄 생략
            - 예시 1: `* **토큰 사용량**: Input 55,000 / Output 15,000 (Total: 70,000)`
            - 예시 2: `* **토큰 사용량**: Total: 70,000`
        - **대화 턴 수**: 해당 커밋을 위한 대화 턴만 카운트
        - **주요 작업 내용**: 커밋에 포함된 변경사항과 직접 연관된 작업만 명시 (코드 작성/리팩토링/디버깅/문서화 등)
    - Commit 메시지 마지막에 한 줄 띄고 Jira 링크를 추가합니다
        - 브랜치 이름에서 이슈 번호를 추출하여 Jira 링크를 생성합니다
        - 형식: <https://jira.team.musinsa.com/browse/ISSUE-NUMBER>
        - 브랜치 이름에서 이슈 번호를 찾을 수 없는 경우 링크를 생략합니다
    - AI Co-authored-By를 무조건 추가합니다:
        - 형식: `Co-authored-By: [AI Tool Name] <noreply@[domain].com>`
        - AI 도구 종류에 따른 예시:
            - Claude → `Co-authored-By: Claude <noreply@anthropic.com>`
            - Cursor → `Co-authored-By: Cursor <noreply@cursor.sh>`
            - Codex → `Co-authored-By: Codex <noreply@openai.com>`

5. Commit 메시지 출력 및 확인:
    - Commit 메시지는 복사하기 편한 간결한 형식으로 출력합니다 (불필요한 설명 없이 바로 복사·붙여넣기 가능한 형태)
    - 생성된 commit 메시지를 보여주고 "이대로 commit 해드릴까요? (y/n)" 질문을 합니다.

6. Commit 실행:
    - 사용자가 긍정하면 실제 commit을 실행합니다.
    - 'y' 이외에도 다양한 긍정적 응답(예: 'ㅇ', 'ㄱ', 'ㅇㅇ', 'ㄱㄱ', 'rr', '어 예스!', 'yes', 'Y', '예', '응')을 인식하여 commit을 진행합니다.
    - 참고: 'rr'은 한글 'ㄱㄱ'를 영문 키보드로 타이핑했을 때 나오는 문자로, 실수로 또는 편의상 한글로 바꾸지 않고 그대로 입력하는 경우가 있어 긍정 응답으로 인식합니다.
    - 예시:
        - y
        - Y
        - yes
        - ㅇ (1글자도 인식)
        - ㄱ (1글자도 인식)
        - ㅇㅇ / ㅇㅇㅇㅇ
        - ㄱㄱ / ㄱㄱㄱㄱ
        - rr (ㄱㄱ의 영문 키보드 입력)
        - 어 예스!
        - 예
        - 응

### 자동 모드 (`/commit --auto`)

1. 자동으로 사전 commit 검사를 실행합니다:
    - `pnpm lint` 실행으로 코드 품질 확인
    - `pnpm build` 실행으로 빌드 성공 여부 확인
    - 사전 검사가 실패하면 오류 메시지를 표시하고 중단합니다.
2. 위의 기본 모드 1-4단계를 실행하고 commit 메시지를 생성합니다.
    - 자동 실행된 git 명령어 결과를 활용합니다.
3. 사용자 확인 없이 생성된 commit 메시지로 `git commit -m "메시지"` 를 자동 실행합니다.

### 자동 모드 (검사 제외) (`/commit --auto-no-verify`)

1. 사전 commit 검사를 건너뜁니다.
2. 위의 기본 모드 1-4단계를 실행하고 commit 메시지를 생성합니다.
    - 자동 실행된 git 명령어 결과를 활용합니다.
3. 사용자 확인 없이 생성된 commit 메시지로 `git commit -m "메시지"` 를 자동 실행합니다.

## Commit 모범 사례

- main 브랜치 보호: main/master 브랜치에서 직접 커밋 금지
- 브랜치명 규칙: @.claude/docs/common/branch-naming-rules.md 참조
- Commit 전 검증: 린트, 빌드, 문서 업데이트 확인
- Atomic commit: 각 commit은 단일 목적만 포함
- 큰 변경사항 분할: 여러 관심사는 별도의 commit으로 분할
- Conventional Commits 형식: `<type>: [<issue-key>] <설명>` 형식 사용
  - `feat`: 새로운 기능
  - `fix`: 버그 수정
  - `docs`: 문서 변경
  - `style`: 코드 스타일 변경 (포맷팅 등)
  - `refactor`: 버그 수정이나 기능 추가가 아닌 코드 변경
  - `perf`: 성능 개선
  - `test`: 테스트 추가 또는 수정
  - `chore`: 빌드 프로세스, 도구 등의 변경
  - `ci`: CI/CD 설정 변경
- 현재 시제, 명령형: Commit 메시지는 명령문으로 작성 (예: "기능 추가" - "기능을 추가했음" X)
- 간결한 첫 줄: 첫 줄은 72자 이내로 유지

## 기여도 산정 가이드라인 (Contribution Guidelines)

모든 커밋 메시지에는 사용자와 AI의 기여도를 명시해야 합니다.

### 기여도 산정 원칙

**⚠️ 중요**: 기여도는 단순 코드 라인 수가 아니라, **로직의 핵심 아이디어**, **구조적 설계 결정**, **문제 해결 방향성**을 중심으로 산정합니다.
- 100줄의 보일러플레이트 코드 < 10줄의 핵심 알고리즘 설계
- AI가 많은 코드를 작성했더라도, 사용자가 방향을 제시하고 검증했다면 사용자 기여도를 높게 평가

### 사용자 기여 인정 기준

- 💡 **아이디어/기획**: 문제 식별, 해결책 제안, 기술 선택 방향성 제시
- 🎯 **방향성 설정**: 작업 범위 정의, 우선순위 결정, 요구사항 명세
- 📋 **의사결정**: 라이브러리 선택, 아키텍처 결정, 디자인 패턴 선택
- 🔍 **검토/피드백**: 코드 리뷰, 수정 요청, 품질 검증, 테스트 검수

### AI 기여 인정 기준

- 💻 **코드 구현**: 실제 코드 작성, 파일 수정, 컴포넌트 개발
- 🔧 **기술적 해결**: 상세 구현 방법, 오류 해결, 최적화 작업
- 🧪 **테스트/검증**: 코드 테스트, 오류 수정, 품질 보증
- 📚 **문서화**: 주석 작성, README 업데이트, 가이드 작성
- ⚠️ **중요**: 사용자가 AI의 제안을 채택하지 않고 직접 작성한 경우, 사용자 기여도를 더 높게 계산합니다

### 기여도 산정 예시

- **아이디어 + 방향성 제시 + 검증**: 사용자 20-30% | AI 70-80%
- **요구사항 명세 + 상세 기획 + 의사결정**: 사용자 30-40% | AI 60-70%
- **직접 코드 작성 + 검토**: 사용자 50-70% | AI 30-50%
- **AI 제안 거부 후 직접 구현**: 사용자 60-80% | AI 20-40%
- **AI가 전체 구현 + 테스트 + 문서화**: 사용자 10-20% | AI 80-90%
- **복잡한 로직 구현 + 최적화 + 디버깅**: 사용자 20-30% | AI 70-80%

## Commit 분할 가이드라인

diff를 분석할 때 다음 기준으로 commit 분할을 고려합니다:

1. **다른 관심사**: 코드베이스의 관련 없는 부분에 대한 변경
2. **다른 유형의 변경**: 기능, 수정, 리팩토링 등의 혼합
3. **파일 패턴**: 다른 유형의 파일에 대한 변경 (예: 소스 코드 vs 문서)
4. **논리적 그룹화**: 별도로 이해하거나 검토하기 쉬운 변경
5. **크기**: 나눠서 설명하면 더 명확해질 매우 큰 변경

## 출력 형식

Commit 메시지는 다음과 같이 간결하게 출력됩니다:

```text
ci: FE-123 feature flag JSON 검증 GitHub Action 워크플로우 추가

* .github/workflows/validate-feature-flag.yml 파일 추가
* feature-flag.json 파일 변경 시 자동으로 JSON 유효성 검증을 수행하는 CI 워크플로우 구성
* pull request 시 feature-flag 디렉토리의 JSON 파일 변경 감지 및 검증 수행

## 변경사항 (사용자: 50% | AI: 50%)
### 사용자 기여 (50%):
* CI/CD 워크플로우 도입 필요성 제안
* feature-flag JSON 검증 요구사항 명세
* 워크플로우 설계 및 구조 결정
* 검증 결과 처리 방식 결정

### AI 기여 (50%):
* GitHub Actions 워크플로우 파일 작성 (.github/workflows/validate-feature-flag.yml)
* JSON 검증 스크립트 구현
* CI 파이프라인 구성 및 테스트

## AI 작업 메트릭 (AI Metrics)
* **모델**: Claude Sonnet 4.5
* **토큰 사용량**: Input 15,000 / Output 8,500 (Total: 23,500)
* **대화 턴 수**: 3회
* **주요 작업**: 코드 작성, CI/CD 구성

https://jira.team.musinsa.com/browse/FE-123

Co-authored-By: [AI Tool Name] <noreply@[domain].com>
```

불필요한 설명이나 "제안 커밋 메시지:", "이 커밋은...", "이 변경사항은..." 등의 부가 설명 없이 바로 복사해서 사용할 수 있는 형태로 출력됩니다.

## 예시

### 좋은 commit 메시지

- feat: FE-123 사용자 인증 시스템 추가
- fix: QAT-1234 렌더링 프로세스의 메모리 누수 해결
- docs: FE-4444 새 엔드포인트로 API 문서 업데이트
- refactor: FE-12345 파서의 오류 처리 로직 단순화
- fix: FE-12345 컴포넌트 파일의 린터 경고 해결
- chore: FE-12345 개발 도구 설정 프로세스 개선
- feat: FE-12345 거래 검증을 위한 비즈니스 로직 구현
- fix: FE-12345 헤더의 사소한 스타일 불일치 수정
- fix: FE-12345 인증 플로우의 치명적인 보안 취약점 패치
- style: FE-12345 가독성 향상을 위한 컴포넌트 구조 재구성
- fix: FE-12345 더 이상 사용되지 않는 레거시 코드 제거
- feat: FE-12345 사용자 등록 폼에 입력 검증 추가
- fix: FE-12345 실패하는 CI 파이프라인 테스트 해결
- feat: FE-12345 사용자 참여를 위한 분석 추적 구현
- fix: FE-12345 인증 비밀번호 요구사항 강화
- feat: FE-12345 스크린 리더를 위한 폼 접근성 개선

### Commit 분할 예시

- 첫 번째 commit: feat: FE-12345 새 solc 버전 type 정의 추가
- 두 번째 commit: docs: FE-12345 새 solc 버전에 대한 문서 업데이트
- 세 번째 commit: chore: FE-12345 package.json 의존성 업데이트
- 네 번째 commit: feat: FE-12345 새 API 엔드포인트를 위한 type 정의 추가
- 다섯 번째 commit: feat: FE-12345 워커 스레드의 동시성 처리 개선
- 여섯 번째 commit: fix: FE-12345 새 코드의 린팅 문제 해결
- 일곱 번째 commit: test: FE-12345 새 solc 버전 기능을 위한 단위 테스트 추가
- 여덟 번째 commit: fix: FE-12345 보안 취약점이 있는 의존성 업데이트
