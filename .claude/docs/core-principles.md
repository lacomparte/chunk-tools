# 기본 개발 원칙

## 목차

- [적용 범위](#적용-범위)
- [1. 코드 구조 및 가독성](#1-코드-구조-및-가독성)
- [2. 명명 규칙 및 스타일](#2-명명-규칙-및-스타일)
- [3. DRY 원칙 및 중복 제거](#3-dry-원칙-및-중복-제거)
- [4. 모듈화 및 계층 분리](#4-모듈화-및-계층-분리)
- [5. 불변성 및 순수 함수](#5-불변성-및-순수-함수)
- [6. 코드 복잡도 및 유지보수](#6-코드-복잡도-및-유지보수)
- [7. 테스트 전략 및 품질 확보](#7-테스트-전략-및-품질-확보)
- [8. 주석과 문서화](#8-주석과-문서화)
- [9. 리팩토링 및 지속적 개선](#9-리팩토링-및-지속적-개선)
- [10. 재사용성과 확장성](#10-재사용성과-확장성)
- [11. 모노레포 구성 및 관리](#11-모노레포-구성-및-관리)

---

## 적용 범위

이 원칙은 모든 프로젝트와 기술 스택에 공통으로 적용되는 기본 개발 지침입니다.

## 1. 코드 구조 및 가독성

### 단일 책임 원칙 (Single Responsibility Principle)

- 각 파일, 클래스, 함수는 딱 하나의 역할만 담당하도록 설계합니다.
- 여러 가지 로직이 한 곳에 섞여 있으면 모듈화를 통해 분리하세요.

참고: SRP는 SOLID 원칙 중 하나입니다. 설계 시 유연성과 유지보수성을 높이려면, OCP(개방-폐쇄), LSP(리스코프 치환), ISP(인터페이스 분리), DIP(의존 역전) 등 SOLID 전반을 함께 적용하는 것이 좋습니다.

### 폴더 및 파일 구조

- 폴더 구조는 도메인 또는 기능 단위로 분리해, 탐색이 직관적이도록 만듭니다.
- 파일명은 해당 로직의 핵심 기능을 분명히 드러내는 이름으로 짓습니다.

### 짧은 함수와 메서드

- 함수는 25줄을 넘기지 않도록 하여, 단일 개념에 집중하게 합니다.
- 25줄이 넘는 함수를 발견하면 바로 로직을 세분화하여 분리합니다.

## 2. 명명 규칙 및 스타일

### 의도가 드러나는 명칭

- 변수, 함수, 클래스 이름에 해당 대상의 역할과 의도가 분명히 나타나도록 합니다.
- 축약어를 지양하고, 검색 가능한 이름을 사용합니다. (예: userProfile, fetchUserData 등)

### 일관된 컨벤션

- CamelCase, PascalCase 등 프로젝트 내에서 합의된 컨벤션을 철저히 지킵니다.
- 함수와 변수는 소문자 시작(예: doSomething), 클래스와 타입은 대문자 시작(예: UserModel)처럼 역할별 구분을 명확히 합니다.

### 자동화된 포매터 및 린터

- ESLint 등 린트 툴과 Prettier 등 포매터를 도입해 코드 스타일을 자동으로 유지합니다.
- 전역에서 동일한 규칙을 적용하여, 스타일 문제로 인한 코드 이력을 최소화합니다.

## 3. DRY 원칙 및 중복 제거

### 중복 로직 파악

- 같은 로직이 여러 곳에서 반복되면, 즉시 공용 함수(또는 모듈)로 추출합니다.
- 상수를 여러 곳에서 참조할 경우, 공통 상수 파일을 만들어 공유합니다.

### 함수 및 컴포넌트 재사용성

- 범용적으로 사용 가능한 로직이라면, 특정 모듈에만 국한되지 않도록 재사용 가능한 구조로 작성합니다.
- UI 컴포넌트도 범용성을 먼저 고려하고, 필요 시 확장을 쉽게 할 수 있도록 만듭니다.

### 템플릿화

- 반복되는 텍스트나 코드를 템플릿으로 만들어두고 동적으로 데이터를 주입하는 방식을 사용하면 유지보수 비용이 줄어듭니다.

## 4. 모듈화 및 계층 분리

### 핵심 로직 vs 보조 로직 분리

- 비즈니스 로직(핵심)과 인프라/도구 로직(보조)을 다른 모듈에 배치하여 관심사를 분리합니다.
- FSD folder architecture 를 base rule 로 합니다.
- 예: entities/ 디렉터리 pages/ 폴더 기반으로 폴더 생성 후 요청-응답 처리, features/는 핵심 비즈니스 로직 및 log 처리, utils/는 범용 유틸 함수 등.

### 명확한 의존성 방향

- 하위(낮은 수준) 모듈이 상위(높은 수준) 모듈을 참조하지 않도록 의존성 흐름을 한 방향으로 고정합니다.
- 의존성 주입(DI) 패턴을 활용해 테스트와 재사용성을 극대화할 수 있습니다.

### 재사용 가능한 라이브러리화

- 공통으로 사용되는 로직은 별도 라이브러리(패키지)나 유틸 디렉터리로 옮겨, 프로젝트 전체에서 재사용할 수 있도록 합니다.
- 버전 관리를 통해 변경 이력과 호환성을 관리합니다.

## 5. 불변성 및 순수 함수

### 불변 데이터

- 가능한 한 Immutable 자료 구조를 사용하고, 원본을 직접 수정하지 않습니다.
- 새로운 변수를 생성해 값을 할당하는 방식으로 사이드 이펙트를 최소화합니다.

### 순수 함수(순수성 유지)

- 함수 내부에서 외부 상태를 참조하거나 변경하는 것을 피하고, 입력값만으로 동작하도록 작성합니다.
- 테스트가 용이해지고, 예측 가능성이 높아집니다.

## 6. 코드 복잡도 및 유지보수

### Cyclomatic Complexity(순환 복잡도)

- 한 함수/메서드 내의 분기(if, switch)가 많아지면 복잡도가 상승합니다.
- 복잡도가 10을 넘어서면 함수를 분할하거나 로직을 단순화하는 리팩토링을 고려합니다.

### 조건문 단순화

- 중첩된 조건문(If-else depth)이 2단계를 넘기지 않도록 주의합니다.
- Guard clause(초기 return) 등을 사용해 가독성을 높입니다.

### 마법 숫자(Magic Number) 제거

- 의미가 불분명한 숫자나 문자열 리터럴은 가능한 상수로 추출합니다. 불가능할 경우 열거형(enum)으로 추출합니다.
- 주석 대신 명확한 상수명으로 의도를 드러냅니다.

## 7. 테스트 전략 및 품질 확보

### 핵심 로직 우선 테스트

- 가장 중요한 비즈니스 로직부터 철저히 테스트해 결함을 조기에 발견합니다.
- 유닛 테스트로 각 함수의 입력-출력에 대한 확실한 보증을 만듭니다.

### 테스트 커버리지 목표

- 단위 테스트(Unit Test): 비즈니스 로직의 90% 이상
- 통합 테스트(Integration): 레이어 간 연동이 필요한 핵심 경로
- E2E 테스트: 실제 사용 시나리오의 주요 흐름

### 자동화된 테스트 실행

- 커맨드 한 번으로 전체 테스트가 수행되도록 설정합니다.
- 오류 시 즉시 로컬에서 재현 가능하도록, 테스트 환경을 간단하게 유지합니다.

추가 팁: 테스트 피라미드(단위 → 통합 → E2E)를 기반으로 QA 전략을 설계하면, 단위 테스트로 기초를 탄탄히 하고 통합/시스템/E2E 테스트에서 주요 시나리오를 점검할 수 있습니다.

## 8. 주석과 문서화

### 필요 최소한의 주석

- 코드는 자기 문서화(self-documenting)가 원칙입니다.
- 복잡한 알고리즘이나 의도를 명시해야 하는 경우에만, 짧고 명료하게 주석을 추가합니다.

예시:

- 특정 복잡도가 높은 알고리즘의 핵심 로직
- 외부 API 호출 시 주의해야 할 파라미터, 사용 제한 등

### Docstring / JSDoc / TSDoc

- 함수나 클래스 위에 파라미터, 리턴값, 예외사항을 표시하는 주석을 달아두면 유지보수 시 큰 도움이 됩니다.
- 자동 문서화 도구와 연동해, API 레퍼런스 등을 쉽게 생성하도록 합니다.

### 핵심 설계 문서

- 아키텍처나 모듈 설계 의사결정이 중요한 경우, 변경 이력과 함께 간단히 문서화하여 추후 레거시 처리나 확장 시 참고할 수 있게 합니다.

## 9. 리팩토링 및 지속적 개선

### 지속적 리팩토링

- 새 기능 추가 시, 기존 코드를 점검해 중복 제거와 구조 개선을 함께 진행합니다.
- 추후 대규모 수정이 필요하지 않도록 점진적인 리팩토링을 습관화합니다.

### 기술 부채 관리

- 급한 구현으로 인해 임시 방편이 생기면, 반드시 기록해두고 가능한 한 빨리 개선합니다.
- 주기적으로 코드 스멜(Code Smell)을 확인해, 유지보수성이 떨어지는 부분을 우선적으로 정리합니다.

### 자동 분석 툴 활용

- 정적 분석(Static Analysis) 도구를 통해 복잡도, 코드 스멜, 사용되지 않는 코드 등을 주기적으로 체크합니다.
- 코드 커버리지 리포트, 린트 에러 등 품질 지표를 꾸준히 모니터링해 점진적 개선을 유도합니다.

## 10. 재사용성과 확장성

### 유연한 설계

- 변동이 예상되는 부분은 인터페이스나 추상화를 통해 유연성을 확보합니다.
- 반드시 필요한 부분에만 인터페이스를 적용하고, 지나친 추상화로 복잡도가 올라가지 않도록 주의합니다.

### 오픈-클로즈드 원칙(개방-폐쇄)

- 기능 확장은 쉽고, 기존 코드 변경은 최소화하도록 설계합니다.
- 예: 전략 패턴, 팩토리 패턴 등을 적용해 로직 확장 시 수정 범위를 최소화할 수 있습니다.

### 범용 유틸 기능 분리

- 프로젝트 전반에서 사용될 가능성이 있는 유틸 함수(예: 날짜 변환, 문자열 파싱 등)는 별도 모듈로 분리해 재사용합니다.
- 중복된 유틸 코드가 있으면 즉시 통합하고, 다른 코드에서 참조하도록 유도합니다.

## 11. 모노레포 구성 및 관리

### 프로젝트 구조 이해

이 프로젝트는 pnpm workspace를 사용한 모노레포 구조입니다:
apps/ 하위의 독립 실행 가능한 애플리케이션은 모두 /shared, /mobile, /pc 폴더를 갖고 있습니다.
단, /menu 제외

```
discovery-frontend/
├── apps/                # 독립 실행 가능한 애플리케이션들
│   ├── home/            # 홈 페이지
│   │     ├── mobile/    # 홈 페이지의 mobile용 사용 코드
│   │     ├── pc/        # 홈 페이지의 pc용 사용 코드
│   │     └── shared/    # 홈 페이지의 pc/mobile 공통 사용 코드
│   ├── brand/           # 브랜드 페이지
│   ├── category/        # 카테고리 페이지
│   ├── search/          # 검색 페이지
│   ├── pdp/             # 상품 상세 페이지
│   └── ...              # 기타 페이지별 앱들
├── packages/            # 공유 라이브러리 및 패키지들
│   ├── api-client/      # API 클라이언트
│   ├── hooks/           # 공통 훅들
│   ├── utils/           # 공통 유틸리티
│   ├── constants/       # 공통 상수들
│   ├── plp              # 필터 컴포넌트
│   └── ...              # 기타 공유 패키지들
└── libs/                # 특수 목적 라이브러리들
    └── virtual-scroll/  # 가상 스크롤 라이브러리
```

### 워크스페이스 관리 원칙

#### 패키지 분리 기준

- **apps/**: 독립적으로 배포 가능한 완전한 애플리케이션
- **packages/**: 여러 앱에서 재사용되는 공통 기능들
- **libs/**: 특수 목적의 독립적인 라이브러리

#### 의존성 관리

```typescript
// 권장: 내부 패키지 참조 시 workspace 프로토콜 사용
{
  "dependencies": {
    "@discovery/api-client": "workspace:*",
    "@discovery/hooks": "workspace:*"
  }
}

// 권장: 패키지 내부에서 다른 패키지 import
import { useProduct } from '@discovery/hooks';
import { apiClient } from '@discovery/api-client';
```

### 개발 워크플로우

#### 스크립트 실행

```bash
# 특정 앱 개발 서버 실행
pnpm home:dev          # 홈 앱 개발 서버
pnpm search:dev        # 검색 앱 개발 서버
pnpm brand:dev:pc      # 브랜드 앱 PC 버전 개발 서버

# 특정 앱 빌드
pnpm home:build        # 홈 앱 빌드
pnpm search:build:pc   # 검색 앱 PC 버전 빌드

# 전체 프로젝트 린트
pnpm lint:fixAll       # 모든 패키지 린트 수정
```

#### 패키지 간 의존성 추가

```bash
# apps/home에서 packages/hooks 의존성 추가
pnpm add @discovery/hooks --filter home

# packages/utils에서 packages/constants 의존성 추가
pnpm add @discovery/constants --filter utils
```

### 공유 코드 관리

#### 패키지별 책임 분리

```typescript
// packages/hooks/ - 재사용 가능한 커스텀 훅들
export const useProduct = () => {
  /* ... */
};
export const useCart = () => {
  /* ... */
};

// packages/utils/ - 순수 함수들
export const formatPrice = (price: number) => {
  /* ... */
};
export const validateEmail = (email: string) => {
  /* ... */
};

// packages/api-client/ - API 통신 로직
export const productApi = {
  /* ... */
};
export const userApi = {
  /* ... */
};
```

#### 타입 공유

```typescript
// packages/@types/ - 공통 타입 정의
// 되도록이면 type 사용지향 interface 는 후 순위
export type Product = {
  id: string;
  name: string;
  price: number;
};

export type User = {
  id: string;
  email: string;
};

// 각 앱에서 타입 사용
import type { Product, User } from '@discovery/@types';
```

### 빌드 및 배포 전략

#### 개별 앱 빌드

```bash
# 특정 앱만 빌드
pnpm home:build        # 홈 앱만 빌드
pnpm search:build:pc   # 검색 앱 PC 버전만 빌드

# 모든 앱 빌드
pnpm -r build          # 모든 패키지 빌드
```

#### 의존성 순서 고려

```typescript
// packages/ 내부 의존성 순서
// 1. constants (가장 기본)
// 2. utils (constants에 의존)
// 3. api-client (utils에 의존)
// 4. hooks (api-client에 의존)
// 5. components (hooks에 의존)
```

### 개발 환경 설정

#### IDE 설정

```json
// .vscode/settings.json
{
  "typescript.preferences.importModuleSpecifier": "relative",
  "eslint.workingDirectories": ["apps/*", "packages/*", "libs/*"]
}
```

#### 디버깅 설정

```json
// .vscode/launch.json
{
  "configurations": [
    {
      "name": "Debug Home App",
      "type": "node",
      "request": "launch",
      "program": "${workspaceFolder}/apps/home/src/main.tsx",
      "cwd": "${workspaceFolder}/apps/home"
    }
  ]
}
```

#### 캐싱 전략

```bash
# pnpm 캐시 활용
pnpm store prune    # 사용하지 않는 패키지 정리
pnpm store status   # 캐시 상태 확인
```

### 모노레포 모범 사례

#### 1. 패키지 버전 관리

```json
// 루트 package.json에서 공통 의존성 버전 고정
{
  "resolutions": {
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "@musinsa/frontend-ui": "^1.0.119"
  }
}
```

#### 2. 공통 설정 파일

```typescript
// 루트 레벨에서 공통 설정 관리
// .eslintrc.js, .prettierrc, tsconfig.json 등
```

#### 3. 변경사항 추적

```bash
# 특정 패키지 변경사항 확인
pnpm -r --filter=home run build

# 의존성 그래프 확인
pnpm list --depth=2
```

### 문제 해결 가이드

#### 일반적인 이슈들

1. **의존성 충돌**: `pnpm install --force`로 해결
2. **캐시 문제**: `pnpm store prune` 후 재설치
3. **타입 에러**: `pnpm -r type-check`로 전체 타입 체크

#### 개발 팁

- 새로운 공통 기능은 먼저 `packages/`에 배치 고려
- 앱별 특수 로직은 해당 앱 내부에 유지
- 패키지 간 순환 의존성 금지
- 공통 타입은 `packages/@types/`에 중앙 관리

이 모노레포 구조를 통해 코드 재사용성을 극대화하고, 개발 효율성을 향상시킬 수 있습니다.
